HECHO:

1) Corregir que player no sea mas singleton

1.1) Seteado el namespace RPG.GameCore para los managers del juego
1.2) Creada clase PlayerStatsManager para manejar los stats importantes a guardar del Player
1.3) Creada clase AutoSavePlayerStatsDataManager para manejar un pequeño autosave para actualizar el playerstatsmanager cada cierto período de tiempo
1.4) Implementadas las clases PlayerStatsManager y AutoSavePlayerStatsDataManager en el GameManager para que este vaya guardando y actualizando los datos necesarios del Player para que así este deje de ser singleton y asignar la información a un nuevo player cada vez que se avance de nivel
1.5) Los stats a guardar de PlayerStatsManager son:

- Salud y salud máxima
- Mana y mana máximo
- Listado de pociones
- Arma melee equipada, arma a distancia equipada y arma activa
- Posición del jugador

2) En el AIController cuando el enemigo es atacado por el player puede atacar automáticamente, sin importar la chaseDistance. Esto utilizando un EventManager que conecta la salud del enemigo que, al recibir un daño por el player, setea en true un booleano que detecta si fue atacado por el player para proceder a atacar.

NOTA: fue necesario agregar un id tanto en la salud del enemigo como en el controller debido a que si y solo si seteara en true la variable del script cuyo id sea igual al de la salud, con el fin de evitar que todos los scripts de AIController seteen la variable en true. De momento la id se setea en el inspector pero en un futuro se agregara un script que levante todos los AIController (array) de una escena y le seteara por medio de un for respecto a su indice en el mismo.

3) Corregido bug de que no funcionaba la fireball del Boss. Para esto se realizaron los siguientes cambios:

3.1) Se crearon MagicSpawners para que las magias al ser "equipadas" no deriven la responsabilidad de instanciar los hechizos en los spawners
3.2) Se creo un spawner para la MagicArea y MagicProjecile
3.3) Se creo en el MagicCaster un diccionario que setea el transform desde donde se instanciará el spawner según su tipo de magia:
- Si es magia en area, su transform será el transform del caster
- Si es magia de proyectil, su transform será (de momento) la mano derecha del caster

4) Corregido Feature de DamageTrigger. PAra esto se realizaron los siguientes cambios:
4.1) Se creo un DamageTrigger individual por cada personaje (jugador y enemigos)
4.2) El attackTrigger de las armas ahora seteará el DamageTrigger del personaje en lugar de uno propio. Además de que tendrá la información para setear el center y el size del boxCollider del DamageTrigger (además de setear el daño y demás)
4.3) Por último al atacar, el attackTrigger activa y desactiva el DamageTrigger del personaje

5) Corregido pequeño bug de que el fireball no se casteaba correctamente ya que era interrumpido por el ataque del boss, se solucionó con setear en EnemyCaster un booleano para que chequee si está casteando o no un hechizo. En el caso de que esté casteando no podrá atacar

6) Aplicado en MVC en Player reemplazando PlayerController (ahora renombrado como PlayerController Old) por PlayerMVC que funciona como User para manejar el Model, View y Controller del Player (PlayerModel, PlayerView y PlayerController).

PlayerController: Se encarga del manejo de Inputs y Raycasts del Player para que interactúe con el PlayerModel
PlayerModel: Se encarga de la lógica de interacción de Inputs del PlayerController
PlayerView: Controla el feedback visual y sonoro del Player
PlayerMVC: Maneja los updates, los eventos del PlayerModel y la integración del PlayerView al PlayerModel

Cosas a tener en cuenta:

- Surge una advertencia de "You are trying to create a MonoBehaviour using the 'new' keyword.  This is not allowed.  MonoBehaviours can only be added using AddComponent(). Alternatively, your script can inherit from ScriptableObject or no base class at all" en PlayerModel y PlayerView. Esto conlleva a que dentro de ambos scripts no pueda realizar acciones de MonoBehaviour tales como GetComponent, StartCoroutine, Invoke, etc ya que me genera un NullReferenceExcepcion. Por el momento está solucionado con el patrón EventManager en donde el PlayerMVC maneja eventos con acciones de MonoBehaviour, el PlayerModel y el PlayerView llaman a los eventos del PlayerMVC y así realizan sus acciones correctamente y no se genera el NullReference.

- El PlayerView aún está muy verde ya que gran parte del feedback visual y sonoro aún se ejecutan en scripts externos a los del PlayerMVC y derivados.


BUGS:
1) Nullreference exception que sale con el sistema de layers
CORREGIDO: creado DamageTrigger que funciona de intermediario
entre el AttackTrigger y el CombatTarget
2) Error al setear la info del proyectil del hechizo de bola
de fuego del boss <Corregido>
3) En el PlayerMVC el PlayerModel y el PlayerView me sale un warning de:
"You are trying to create a MonoBehaviour using the 'new' keyword.  This is not allowed.  MonoBehaviours can only be added using AddComponent(). Alternatively, your script can inherit from ScriptableObject or no base class at all" y al querer realizar acciones de MonoBehaviour me sale NullReferenceError <Arreglado... Kinda>

En proceso:

1) En lugar de abstract cambiar por virtual y aplicar base.Clase() a las clases vacías
2) Aplicando MVC al Character. Lo que falta setear:
- WeaponInventory
- InventoryMenu
- MagicCaster
- Fighter
- Movement

PATRONES

1) MVC en los characters (player, enemies y boss)
1.1) Model tomará casi toda las funciones de los scripts PlayerController y AIController
1.2) Controller tomará los inputs y los raycasts del PlayerController y el Mover de AIController
1.3) View se encargará del feedback visual y auditivo (pendiente a corregir/modificar código en los scripts Health y sus derivados, Mover, Fighter, MagicCaster, etc)
2) Ver Flyweight, si no convence Decorator, si no convence Localization Manager
3) Screen Manager (Esto lo haría sol y si se le complica veo de ayudarla)
4) Setear mas ObjectPools/Factories + Consultar al profe por pools con mismo script pero distinto gameObject (Buscar todo lo que tenga un Instantiate y cambiarlo por el patrón)

CRITICO: cuando sol termine el UI implementarlo ingame y setear/corregir lo necesario en cuestión de programación